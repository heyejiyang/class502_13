객체종류
--Q1 ^^
CREATE TABLE EMPIDX AS SELECT * FROM EMP;

SELECT * FROM EMPIDX;

CREATE INDEX IDX_EMPIDX_EMPNO
	ON EMPIDX(EMPNO);
	
SELECT * FROM USER_INDEXES
	WHERE INDEX_NAME = 'IDX_EMPIDX_EMPNO';


--Q2
CREATE OR REPLACE VIEW EMPIDX_OVER15K
AS (SELECT EMPNO, ENAME, JOB, DEPTNO, SAL, NVL2(COMM,'O','X') AS COMM  FROM EMPIDX
	WHERE SAL > 1500 );

SELECT * FROM EMPIDX_OVER15K;

--Q3
CREATE TABLE DEPTSEQ AS SELECT * FROM DEPT;

CREATE SEQUENCE SEQ_DEPT_SEQUENCE2
	INCREMENT BY 1
	START WITH 1
	MAXVALUE 99
	MINVALUE 1
	NOCACHE;

INSERT INTO DEPTSEQ(DEPTNO, DNAME, LOC)
VALUES(SEQ_DEPT_SEQUENCE2.NEXTVAL,'DATABASE','SEOUL');

INSERT INTO DEPTSEQ(DEPTNO, DNAME, LOC)
VALUES(SEQ_DEPT_SEQUENCE2.NEXTVAL,'WEB','BUSAN');

INSERT INTO DEPTSEQ(DEPTNO, DNAME, LOC)
VALUES(SEQ_DEPT_SEQUENCE2.NEXTVAL,'MOBILE','ILSAN');

SELECT * FROM DEPTSEQ;

제약조건
--Q1 ^^
CREATE TABLE EMPIDX AS SELECT * FROM EMP;

SELECT * FROM EMPIDX;

CREATE INDEX IDX_EMPIDX_EMPNO
	ON EMPIDX(EMPNO);
	
SELECT * FROM USER_INDEXES
	WHERE INDEX_NAME = 'IDX_EMPIDX_EMPNO';
--① ^^
CREATE TABLE DEPT_CONST ( 
   DEPTNO NUMBER(2)    CONSTRAINT DEPTCONST_DEPTNO_PK PRIMARY KEY, 
   DNAME  VARCHAR2(14) CONSTRAINT DEPTCONST_DNAME_UNQ UNIQUE, 
   LOC    VARCHAR2(13) CONSTRAINT DEPTCONST_LOC_NN NOT NULL 
);

--② ^^
CREATE TABLE EMP_CONST ( 
   EMPNO    NUMBER(4) CONSTRAINT EMPCONST_EMPNO_PK PRIMARY KEY, 
   ENAME    VARCHAR2(10) CONSTRAINT EMPCONST_ENAME_NN NOT NULL, 
   JOB      VARCHAR2(9), 
   TEL      VARCHAR2(20) CONSTRAINT EMPCONST_TEL_UNQ UNIQUE, 
   HIREDATE DATE, 
   SAL      NUMBER(7, 2) CONSTRAINT EMPCONST_SAL_CHK CHECK (SAL BETWEEN 1000 AND 9999), 
   COMM     NUMBER(7, 2), 
   DEPTNO   NUMBER(2) CONSTRAINT EMPCONST_DEPTNO_FK REFERENCES DEPT_CONST (DEPTNO) 
); 
	     
--③
SELECT TABLE_NAME, CONSTRAINT_NAME, CONSTRAINT_TYPE 
  FROM USER_CONSTRAINTS 
 WHERE TABLE_NAME IN ( 'EMP_CONST', 'DEPT_CONST' ) 
ORDER BY CONSTRAINT_NAME; 

PL/SQL기초
--Q1 ^^
CREATE TABLE EMPIDX AS SELECT * FROM EMP;

SELECT * FROM EMPIDX;

CREATE INDEX IDX_EMPIDX_EMPNO
	ON EMPIDX(EMPNO);
	
SELECT * FROM USER_INDEXES
	WHERE INDEX_NAME = 'IDX_EMPIDX_EMPNO';
--① ^^
CREATE TABLE DEPT_CONST ( 
   DEPTNO NUMBER(2)    CONSTRAINT DEPTCONST_DEPTNO_PK PRIMARY KEY, 
   DNAME  VARCHAR2(14) CONSTRAINT DEPTCONST_DNAME_UNQ UNIQUE, 
   LOC    VARCHAR2(13) CONSTRAINT DEPTCONST_LOC_NN NOT NULL 
);

Q1. 

DECLARE
	
BEGIN
	FOR i IN 1..10 LOOP
		IF MOD(i,2) = 1 THEN
			DBMS_OUTPUT.PUT_LINE('현재 i의 값: ' || i);
		END IF;
	END LOOP;
END;


Q2.

DECLARE
	V_DEPTNO DEPT.DEPTNO%TYPE;
BEGIN
	V_DEPTNO := 60;
	CASE V_DEPTNO
		WHEN 10 THEN
		DBMS_OUTPUT.PUT_LINE('DNAME : ACCOUNTING');
		WHEN 20 THEN
		DBMS_OUTPUT.PUT_LINE('DNAME : RESEARCH');
		WHEN 30 THEN
		DBMS_OUTPUT.PUT_LINE('DNAME : SALES');
		WHEN 40 THEN
		DBMS_OUTPUT.PUT_LINE('DNAME : OPERATIONS');
		ELSE
			DBMS_OUTPUT.PUT_LINE('N/A');
	END CASE;
END;

커서와 예외처리
Q1 LOOP사용
DECLARE
	V_EMP EMP%ROWTYPE;
	CURSOR C1 IS SELECT * FROM EMP;
BEGIN
	OPEN C1;
	LOOP
		FETCH C1 INTO V_EMP;
		EXIT WHEN C1%NOTFOUND;
		DBMS_OUTPUT.PUT_LINE('EMPNO: '|| V_EMP.EMPNO || ', ENAME:'|| V_EMP.ENAME
		|| ', JOB: '|| V_EMP.JOB || ', SAL: '|| V_EMP.SAL || ', DEPTNO: '|| V_EMP.DEPTNO);
	END LOOP;
	
	CLOSE C1;
END;

FOR LOOP 사용
DECLARE
	CURSOR C1 IS SELECT * FROM EMP;
BEGIN
	FOR i IN C1 LOOP
		DBMS_OUTPUT.PUT_LINE('EMPNO: '|| i.EMPNO || ', ENAME:'|| i.ENAME
		|| ', JOB: '|| i.JOB || ', SAL: '|| i.SAL || ', DEPTNO: '|| i.DEPTNO);
	END LOOP;
END;

Q2
DECLARE
	v_wrong DATE;
BEGIN
	SELECT ENAME INTO v_wrong
		FROM EMP
	WHERE EMPNO = 7369;

	DBMS_OUTPUT.PUT_LINE('예외가 발생하면 다음 문장은 실행되지 않습니다.');

	EXCEPTION
		WHEN OTHERS THEN
			DBMS_OUTPUT.PUT_LINE('오류가 발생하였습니다.' 
                        || TO_CHAR(SYSDATE, 
                        '[YYYY"년"MM"월"DD"일" HH24"시"mm"분"SS"초"]'));
			DBMS_OUTPUT.PUT_LINE('SQLCODE : '|| TO_CHAR(SQLCODE));
			DBMS_OUTPUT.PUT_LINE('SQLERRM : '|| SQLERRM);
END;

저장 서브프로그램

CREATE OR REPLACE FUNCTION func_date_kor(
	P_DATE DATE
)
RETURN VARCHAR2
IS   
BEGIN
   RETURN (TO_CHAR(P_DATE, 'YYYY"년"MM"월"DD"일"'));
END func_date_kor;

